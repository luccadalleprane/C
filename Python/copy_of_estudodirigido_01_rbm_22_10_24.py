# -*- coding: utf-8 -*-
"""Copy of EstudoDirigido_01_RBM_22/10/24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IZLS-hPyPQIpHMPBfIOa35zamFGLDP-8
"""

import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Parâmetros gerais:
dt = 0.05
tf = 30.0
t = np.arange(0.0, tf, dt)


#################
#### (1)  a. ####
#################

#################
#### (1)  b. ####
#################

#################
#### (1)  c. ####
#################

#################
#### (2)  a. ####
#################

J = 0.01
b = 0.019
Ke = 0.01
Kt = 0.01
R = 1.0
L = 0.5
v_max = 12.0

Kp = 10.0
Ki = 1.0
Kd = 0.02

theta_dot_ref = 3 * np.pi

theta_dot_left = np.zeros(len(t))
theta_dot_right = np.zeros(len(t))
current_left = np.zeros(len(t))
current_right = np.zeros(len(t))
v_left = np.zeros(len(t))
v_right = np.zeros(len(t))
error_left = np.zeros(len(t))
error_right = np.zeros(len(t))
integral_left = 0.0
integral_right = 0.0

theta_dot_left[0] = 0.0
theta_dot_right[0] = 0.0
current_left[0] = 0.0
current_right[0] = 0.0


for k in range(1, len(t)):
    error_left[k] = theta_dot_ref - theta_dot_left[k-1]
    error_right[k] = theta_dot_ref - theta_dot_right[k-1]

    integral_left += error_left[k] * dt
    integral_right += error_right[k] * dt

    derivative_left = (error_left[k] - error_left[k-1]) / dt
    derivative_right = (error_right[k] - error_right[k-1]) / dt

    v_left[k] = Kp * error_left[k] + Ki * integral_left + Kd * derivative_left
    v_right[k] = Kp * error_right[k] + Ki * integral_right + Kd * derivative_right

    v_left[k] = np.clip(v_left[k], -v_max, v_max)
    v_right[k] = np.clip(v_right[k], -v_max, v_max)

    di_left = (v_left[k] - R * current_left[k-1] - Ke * theta_dot_left[k-1]) / L * dt
    current_left[k] = current_left[k-1] + di_left

    d_theta_dot_left = (Kt * current_left[k] - b * theta_dot_left[k-1]) / J * dt
    theta_dot_left[k] = theta_dot_left[k-1] + d_theta_dot_left

    di_right = (v_right[k] - R * current_right[k-1] - Ke * theta_dot_right[k-1]) / L * dt
    current_right[k] = current_right[k-1] + di_right

    d_theta_dot_right = (Kt * current_right[k] - b * theta_dot_right[k-1]) / J * dt
    theta_dot_right[k] = theta_dot_right[k-1] + d_theta_dot_right

plt.figure(figsize=(10, 5))
plt.plot(t, theta_dot_left, label='Motor Esquerda (rad/s)', color='b')
plt.plot(t, theta_dot_right, label='Motor Direita (rad/s)', color='r')
plt.title('Evolução da Velocidade Angular dos Motores')
plt.xlabel('Tempo (s)')
plt.ylabel('Velocidade Angular (rad/s)')
plt.grid()
plt.legend()
plt.show()

plt.subplot(2, 1, 2)
plt.plot(t, v_left, label='Motor Esquerda (V)', color='b')
plt.plot(t, v_right, label='Motor Direita (V)', color='r')
plt.title('Sinal de Controle (Tensão)')
plt.xlabel('Tempo (s)')
plt.ylabel('Tensão (V)')
plt.grid()
plt.legend()

plt.tight_layout()
plt.show()


#################
#### (3)  a. ####
#################

u = 0.100
w = 0.000
R = 0.035
L = 0.280

we = (2*u + w*L) / (2*R)
wd = (2*u - w*L) / (2*R)

#################
#### (3)  b. ####
#################

theta_dot_ref_left = we
theta_dot_ref_right = wd

for k in range(1, len(t)):
    error_left[k] = theta_dot_ref_left - theta_dot_left[k-1]
    error_right[k] = theta_dot_ref_right - theta_dot_right[k-1]

    integral_left += error_left[k] * dt
    integral_right += error_right[k] * dt

    derivative_left = (error_left[k] - error_left[k-1]) / dt
    derivative_right = (error_right[k] - error_right[k-1]) / dt

    v_left[k] = Kp * error_left[k] + Ki * integral_left + Kd * derivative_left
    v_right[k] = Kp * error_right[k] + Ki * integral_right + Kd * derivative_right

    v_left[k] = np.clip(v_left[k], -v_max, v_max)
    v_right[k] = np.clip(v_right[k], -v_max, v_max)

    di_left = (v_left[k] - R * current_left[k-1] - Ke * theta_dot_left[k-1]) / L * dt
    current_left[k] = current_left[k-1] + di_left

    d_theta_dot_left = (Kt * current_left[k] - b * theta_dot_left[k-1]) / J * dt
    theta_dot_left[k] = theta_dot_left[k-1] + d_theta_dot_left

    di_right = (v_right[k] - R * current_right[k-1] - Ke * theta_dot_right[k-1]) / L * dt
    current_right[k] = current_right[k-1] + di_right

    d_theta_dot_right = (Kt * current_right[k] - b * theta_dot_right[k-1]) / J * dt
    theta_dot_right[k] = theta_dot_right[k-1] + d_theta_dot_right

plt.figure(figsize=(10, 5))
plt.plot(t, theta_dot_left, label='Motor Esquerda (rad/s)', color='b')
plt.plot(t, theta_dot_right, label='Motor Direita (rad/s)', color='r')
plt.plot(t, np.ones(len(t)) * theta_dot_ref_left, 'b--', label='Referência Esquerda')
plt.plot(t, np.ones(len(t)) * theta_dot_ref_right, 'r--', label='Referência Direita')
plt.title('Problema 3(b): Evolução da Velocidade Angular dos Motores')
plt.xlabel('Tempo (s)')
plt.ylabel('Velocidade Angular (rad/s)')
plt.grid()
plt.legend()
plt.show()

#################
#### (3)  c. ####
#################

x = sp.symbols('x')
x_t = round(sp.integrate(u, (x, 0, tf)))

#################
#### (3)  d. ####
#################

x = np.zeros(len(t))

for k in range(1, len(t)):
    u_k = (R / 2) * (theta_dot_left[k] + theta_dot_right[k])
    x[k] = x[k-1] + u_k * dt

plt.figure(figsize=(10, 5))
plt.plot(t, x, label='Posição x estimada (m)', color='g')
plt.title(' Problema 3(d): Evolução da coordenada x (com base na dinâmica dos motores)')
plt.xlabel('Tempo (s)')
plt.ylabel('Posição x (m)')
plt.grid()
plt.legend()
plt.show()


#################
#### (4)  a. ####
#################

#################
#### (4)  b. ####
#################

#################
#### (4)  c. ####
#################

#################
#### (5)  a. ####
#################

#################
#### (5)  b. ####
#################

#################
#### (5)  c. ####
#################

"""# **Problema 2**

**A)** Simulado e plotado no código.

\
**B)** A resposta não é instantânea, isso devido às características do sistema. A resposta é gradual, e depende de fatores como a inércia, o atrito viscoso, a dinâmica elétrica do motor e a ação do controlador PID. Quando aplicamos uma tensão ao motor, a velocidade angular aumenta gradualmente até atingir a referência desejada. No gráfico é possível visualizar que a velocidade não salta imediatamente para a referência, há um tempo de subida até que o sistema estabilize na velocidade desejada.

\
**C)** 5 segundos.

\
**D)** Para gerar um sinal de tensão a partir de um controlador PID na prática, podemos utilizar uma combinação de hardware e técnicas de controle. Utilizando abordagens como o uso de microcontroladores, conversores digital-analógico (DAC), PMW, Amplificadores operacionais, etc.

\
# **Problema 3**

**A)**  Calculado no código, sendo o valor final:

We = 2.857\
Wd = 2.857

\
**B)** Simulado e plotado no código.

\
**C)** Calculado no código, sendo o valor final:

x = 3 metros

\
**D)** Simulado e plotado no código.

\
**E)** A diferença entre os valores de x calculados pelos dois métodos se dá porque o primeiro método assume uma velocidade linear constante u, enquanto o segundo leva em conta as variações de ωe e ωd, afetadas pelo controlador PID e pelas dinâmicas dos motores. As imperfeições e o tempo de resposta do controlador PID fazem com que o u(t) real não seja exatamente constante, resultando em uma diferença no valor final de x.
"""