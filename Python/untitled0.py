# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1biBljBpGXkbtW3ztbyrnkjUIQ-JqDqwy
"""

import numpy as np
import matplotlib.pyplot as plt

# ============================
# Função para calcular as velocidades angulares das rodas
# ============================
def calc_vel_ang(u, omega, L, R):
    omega_e = (u - (L / 2) * omega) / R
    omega_d = (u + (L / 2) * omega) / R
    return omega_e, omega_d

# Parâmetros do robô
R = 0.035  # Raio das rodas (m)
L = 0.28   # Distância entre as rodas (m)
limite_motor = 10  # Limite de operação do motor (rad/s)

# ============================
# Problema 4a e 4b: Gráfico das velocidades angulares para diferentes ω
# ============================

# Velocidades lineares para os dois casos (u = 0.1 e u = 0.2)
u1 = 0.1  # m/s
u2 = 0.2  # m/s

# Geração de valores de ω de 0 até 0.5 rad/s
omega_values = np.linspace(0, 0.5, 100)

# Listas para armazenar as velocidades angulares das rodas (esquerda e direita)
vel_ang_esq_u1, vel_ang_dir_u1 = [], []
vel_ang_esq_u2, vel_ang_dir_u2 = [], []

# Calculando as velocidades angulares para cada ω para u = 0.1 e u = 0.2
for omega in omega_values:
    ve_u1, vd_u1 = calc_vel_ang(u1, omega, L, R)
    vel_ang_esq_u1.append(ve_u1)
    vel_ang_dir_u1.append(vd_u1)

    ve_u2, vd_u2 = calc_vel_ang(u2, omega, L, R)
    vel_ang_esq_u2.append(ve_u2)
    vel_ang_dir_u2.append(vd_u2)

# ============================
# Gráfico para u = 0.1 m/s
# ============================
plt.figure(figsize=(10, 6))

plt.plot(omega_values, vel_ang_esq_u1, label='Velocidade Angular Esquerda (u = 0.1 m/s)', color='blue')
plt.plot(omega_values, vel_ang_dir_u1, label='Velocidade Angular Direita (u = 0.1 m/s)', color='red')

plt.axhline(y=limite_motor, color='green', linestyle='--', label='Limite do motor (10 rad/s)')

plt.xlabel('Velocidade Angular ω (rad/s)')
plt.ylabel('Velocidade das Rodas (rad/s)')
plt.title('Velocidades Angulares das Rodas (u = 0.1 m/s)')
plt.legend()
plt.grid(True)
plt.show()

# ============================
# Gráfico para u = 0.2 m/s
# ============================
plt.figure(figsize=(10, 6))

plt.plot(omega_values, vel_ang_esq_u2, label='Velocidade Angular Esquerda (u = 0.2 m/s)', color='blue')
plt.plot(omega_values, vel_ang_dir_u2, label='Velocidade Angular Direita (u = 0.2 m/s)', color='red')

plt.axhline(y=limite_motor, color='green', linestyle='--', label='Limite do motor (10 rad/s)')

plt.xlabel('Velocidade Angular ω (rad/s)')
plt.ylabel('Velocidade das Rodas (rad/s)')
plt.title('Velocidades Angulares das Rodas (u = 0.2 m/s)')
plt.legend()
plt.grid(True)
plt.show()

# ============================
# Problema 4c: Encontrar o valor máximo de ω permitido para u = 0.1 m/s
# ============================

# Função para encontrar o valor máximo de ω permitido
def max_omega(u, L, R, limite_motor):
    # Precisamos garantir que a maior das duas velocidades não exceda o limite do motor
    omega_max = 2 * ((limite_motor * R) - u) / L
    return omega_max

# Valor máximo de ω para u = 0.1 m/s
omega_max_u1 = max_omega(u1, L, R, limite_motor)

# Mostrar o valor de ω máximo no gráfico
plt.figure(figsize=(10, 6))

# Gráfico para ω crescente até o máximo calculado
omega_values_max = np.linspace(0, omega_max_u1, 100)

vel_ang_esq_max, vel_ang_dir_max = [], []

for omega in omega_values_max:
    ve_max, vd_max = calc_vel_ang(u1, omega, L, R)
    vel_ang_esq_max.append(ve_max)
    vel_ang_dir_max.append(vd_max)

plt.plot(omega_values_max, vel_ang_esq_max, label='Velocidade Angular Esquerda (u = 0.1 m/s)', color='blue')
plt.plot(omega_values_max, vel_ang_dir_max, label='Velocidade Angular Direita (u = 0.1 m/s)', color='red')

plt.axhline(y=limite_motor, color='green', linestyle='--', label='Limite do motor (10 rad/s)')
plt.axvline(x=omega_max_u1, color='purple', linestyle='--', label=f'ω máximo: {omega_max_u1:.2f} rad/s')

plt.xlabel('Velocidade Angular ω (rad/s)')
plt.ylabel('Velocidade das Rodas (rad/s)')
plt.title('Valor Máximo de ω Permitido (u = 0.1 m/s)')
plt.legend()
plt.grid(True)
plt.show()